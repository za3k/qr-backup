#!/usr/bin/env python3
"""
Takes a binary file, and outputs a "paper backup": a printable pdf full of QR codes. 

Following the directions in the pdf, the QR codes can be re-scanned or photographed using a webcame to restore the original file.

Requirements to make the PDF: python 'qrcode' library, imagemagick, img2pdf
Requirements to restore from the PDF: zbar (only)
"""
import PIL, PIL.Image, PIL.ImageDraw, PIL.ImageFont, PIL.ImageOps
import english_wordlist
import base64, datetime, gzip, hashlib, io, logging, math, os, random, subprocess, sys, textwrap, qrcode
assert sys.version_info >= (3,6), "Python 3.6 is required. Submit a patch removing f-strings to fix it, sucka!"

HELP='''Usage: qr-codes.py [OPTIONS] FILE
               qr-codes.py --restore [OPTIONS]
               qr-codes.py --restore [OPTIONS] IMAGE [IMAGE ...]
Convert a binary file to a paper .pdf backup of QR codes. With '--restore',
read the QR codes in the paper backup using a webcam or scanner, to re-create
the original file.

Restore directions are included in the PDF, and do not require qr-backup. Make
sure to test that you can actually read the QR size you select.

Backup options:
    --dpi DPI
        Sets the print resolution of your printer.
        Default: 600
    --compress, --no-compress
        This gives a more compact backup, but partial recovery is impossible.
        Default: compressed
    --encrypt generate, --encrypt PASSPHRASE
        Password-protect the backup. If the passphrase is 'generate', a
        passphrase is automatically generated for you, which you would need
        to store securely or you will be unable to unlock the data.
        Default: disabled
    --encrypt-print-passphrase, --no-encrypt-print-passphrase
        Print the passphrase on a sheet by itself.
        Default: print if generated by qr-code, don't print if passed in
    --error-correction CORRECTION
        Sets the error correction level. Options are L (7%), M (15%), Q (25%),
        and H (30%).
        Default: M (15%)
    --filename FILENAME
        Set the restored filename. Max 32 chars.
        Default: same as <FILE>
    --instructions page|cover|both|none
        Sets how frequently the instructions are printed. If 'cover' or 'both'
        is selected, more verbose instructions will be printed on the cover
        page. 
        Default: page
    --note TEXT
        Add a special note to the printout instructions. Can be anything.
        Default: no note
    --output FILENAME, -o FILENAME
        Set the output pdf path (redirecting stdout also works).
        Default: <FILE>.qr.pdf
    --page WIDTH_POINTS HEIGHT_POINTS
        Sets the usable size of the paper on your printer. This should NOT be
        8.5 x 11 -- make sure to include margins.
        Default: 500px x 600px
    --qr-version VERSION
        Uses QR codes, version VERSION. Versions range from 1-40. The bigger
        the version, the harder to scan but the more data per code.
        Default: 10
    --scale SCALE
        Scale QR codes so that each small square in the QR code is 
        SCALE x SCALE pixels.
        Default: 8px

Restore options:
    --code-count COUNT, -c COUNT
        Specify the number of total QR codes.
        Default: automatic
    --compress, --no-compress
        Force decompression (on/off).
        Default: automatic
    --encrypt PASSPHRASE, --no-encrypt
        Force decryption (on/off) and give the passphrase if decrypting.
        Default: automatic
    --image-restore
        Force image-based (scanner) restore.
        Default: automatic
    --display, --no-display
        For webcam scanning, (display/don't display) a webcam preview.
        Default: display
    --output FILENAME, -o
        Set the restore file path.
        Default: stdout
    --sha256 SHA256
        Include a sha256sum to check the file.
        Default: no check, prints checksum to stderr
    --webcam-restore
        Force webcam-based restore.
        Default: automatic

Options for both:
    --verbose, -v
        Print more detailed information during run
'''
assert all(len(line)<=80 for line in HELP.split("\n"))

COVER = """
DO NOT THROW OUT

This backup was generated using qr-backup, a program to back up computer files to physical paper. The person who made the backup went through a lot of
work to make and print this document, and will probably be mad at you if you throw it out. They will also end up with big problems if/when their important
file goes missing.

To learn more about qr-backup, visit https://github.com/za3k/qr-backup.

== Information about this backup ==

File: {restore_file}
Backup created on: {backup_date}
Size (bytes): {original_len}
SHA256: {sha256sum}
Command used: {nice_cmd}
{notes}
== How to restore ==

You will need access to a Linux computer and a command line. You will also need to install 'zbar' and imagemagick.

To restore using a webcam and the Linux command line:
  Step 1 (scan): zbarcam --raw | tee /tmp/qrs | cut -c1-{code_end}
    Scan each code at least once in any order'
  Step 2 (restore): {howto_restore_cmd} >{restore_file}'
  Step 3 (verify): sha256sum {restore_file} # Check against SHA256 above

To restore using a webcam and qr-backup:
  Step 1: qr-backup --restore

To restore using a scanner and the Linux command line:
  Step 1 (scan): Scan the images with your scanner. Save them as any image format, it doesn't matter.
  Step 2 (scan): zbarimg -q --raw *.png >/tmp/qrs
  Step 3 (restore): {howto_restore_cmd} >{restore_file}
  Step 4 (verify): sha256sum {restore_file} # Check against SHA256 above

To restore using a scanner and qr-backup:
  qr-backup --restore IMAGE1 IMAGE2 ...

== Dear future archivists ==

(You can probably ignore this section)

If you don't have access to the Linux command line, and you don't have access to qr-backup, here is an explanation of how the backup is structured.
You will need a computing device and a great deal of technical expertise to restore this way.

- First, each QR code is scanned. QR is a 2D "bar"code in common use.
  QR is too complex to explain here. It is designed by Denso Wave. Each QR code holds 7 to 2953 bytes as binary data (depends on the settings)
  The error correction level (L/M/Q/H) and version (size, 1-40) are given in "command" under the backup information above.
  Many common devices can scan QR codes, such as 2012-2020 "smart" cell phones.
- Each QR code is labeled--the label matches the data written under the QR code.
  This data only used to label which code is which. It is removed.
- The non-label contents of each QR-code are base64.
  Base64 holds 6 bits per character. The full character set is:
    ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
    = is used as padding so the final size is a multiple of 24 bits
  base64 is detailed in RFC 4648 (base16, base32, and base64). The string "ZXhhbXBsZQ==" is decoded as "example".
  The command-line tool base64 or many commonly-available internet tools provide this function.
  It is reasonable to program a tool to decode base64 yourself. Convert from base-64 given above to base-256 (bytes).
- The decoded base64 from every QR code is appended together in order.
- If the --encrypt option is given, the file must be decrypted.
  The details of GPG decryption are too long to include here, but the algorithm used was AES256.
- If the --compress option is given, the file must be gzip-decompressed.
  The details of gzip are too long to include here, see RFC 1951 (DEFLATE).
  Naming a file "XXX.gz" allows it to be decompressed on Windows, Mac/Apple, BSD, Linux, and Unix. 
- The file is now assembled.
- The file is checksummed using sha256, which verifies the file is perfectly restored.
  The checksum is detailed in United States NIST standard FIPS PUB 180-2 (SHA2)
  Many standard tools like sha256 perform this checksum.
"""

L = qrcode.constants.ERROR_CORRECT_L
M = qrcode.constants.ERROR_CORRECT_M # default, 25%
Q = qrcode.constants.ERROR_CORRECT_Q
H = qrcode.constants.ERROR_CORRECT_H
MODE = qrcode.util.MODE_8BIT_BYTE # not settable. and no, base64 encoded data doesn't bit in alphanumeric (there are only 44 chars)

VERSIONS_BITS = {
    # Binary bits for each version size, 1-40
    # Source: qrcode.com (DENSO WAVE)
    # Order is L,M,Q,H on right
    1: [152,128,104,72],
    2: [272,224,176,128],
    3: [440,352,272,208],
    4: [640,512,384,288],
    5: [864,688,496,368],
    6: [1088,864,608,480],
    7: [1248,992,704,528],
    8: [1552,1232,880,688],
    9: [1856,1456,1056,800],
    10: [2192,1728,1232,976],
    11: [2592,2032,1440,1120],
    12: [2960,2320,1648,1264],
    13: [3424,2672,1952,1440],
    14: [3688,2920,2088,1576],
    15: [4184,3320,2360,1784],
    16: [4712,3624,2600,2024],
    17: [5176,4056,2936,2264],
    18: [5768,4504,3176,2504],
    19: [6360,5016,3560,2728],
    20: [6888,5352,3880,3080],
    21: [7456,5712,4096,3248],
    22: [8048,6256,4544,3536],
    23: [8752,6880,4912,3712],
    24: [9392,7312,5312,4112],
    25: [10208,8000,5744,4304],
    26: [10960,8496,6032,4768],
    27: [11744,9024,6464,5024],
    28: [12248,9544,6968,5288],
    29: [13048,10136,7288,5608],
    30: [13880,10984,7880,5960],
    31: [14744,11640,8264,6344],
    32: [15640,12328,8920,6760],
    33: [16568,13048,9368,7208],
    34: [17528,13800,9848,7688],
    35: [18448,14496,10288,7888],
    36: [19472,15312,10832,8432],
    37: [20528,15936,11408,8768],
    38: [21616,16816,12016,9136],
    39: [22496,17728,12656,9776],
    40: [23648,18672,13328,10208],
}
def qr_size_chars(version, mode, quality):
    assert mode not in [qrcode.util.MODE_NUMBER, qrcode.util.MODE_KANJI]
    assert mode in [qrcode.util.MODE_ALPHA_NUM, qrcode.util.MODE_8BIT_BYTE]

    bits = VERSIONS_BITS[version][[L,M,Q,H].index(quality)]
    data_bits = bits-4-qrcode.util.length_in_bits(mode, version)
    if mode == qrcode.util.MODE_NUMBER: # Not verified
        return (data_bits//10)*3 + [0,0,0,0,1,1,1,2,2,2][data_bits%10]
    elif mode == qrcode.util.MODE_ALPHA_NUM: # Not verified
        return (data_bits//11)*2 + [0,0,0,0,0,0,1,1,1,1,1][data_bits%11]
    elif mode == qrcode.util.MODE_8BIT_BYTE: # Verified
        return math.floor(data_bits/8)
    elif mode == qrcode.util.MODE_KANJI: # Not verified
        return math.floor(data_bits/13)

def qr_grid_size(version):
    return version*4+17

def program_present(program):
    """Return True or False depending on whether the program is found in the environment"""
    return subprocess.call(["which", program], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0

def generate_chunks(data, chunk_size_base64):
    """
    Return a bunch of chunks to put in QRs.
    The returned values must not contain "\n" due to the use of zbarimg/zbarcam, so we base-64 encode everything at the QR level
    """
    
    num_qrs = 0
    for chunk_digits in range(1, 10):
        prefix_format = "N{:0>" + str(chunk_digits) + "}/{:0>" + str(chunk_digits)+"} "
        payload_size_base64 = chunk_size_base64 - len(prefix_format.format(0,0))
        payload_size_bytes = math.floor(payload_size_base64 / 4) * 3 # groups of 4 base-64 digits encode 3 bytes each
        num_qrs = math.ceil(len(data) / payload_size_bytes)
        if num_qrs <= 10**chunk_digits-1:
            break
    assert math.ceil(len(data)/payload_size_bytes) == num_qrs <= 10**chunk_digits-1
    chunks = []
    for i, start in enumerate(range(0, len(data), payload_size_bytes)):
        prefix = prefix_format.format(i+1, num_qrs).encode('ascii')
        chunk_data_bytes = data[start:start+payload_size_bytes]
        assert len(chunk_data_bytes) <= payload_size_bytes
        chunk_data_base64 = base64.b64encode(chunk_data_bytes)
        assert len(chunk_data_base64) <= payload_size_base64
        chunk_content = prefix+chunk_data_base64
        assert len(chunk_content) <= chunk_size_base64
        chunks.append(chunk_content)
    assert len(chunks) == num_qrs
    return chunk_digits, chunks

def qr_codes(data, error_correction, version, scale):
    naive_chunk_size = qr_size_chars(version, MODE, error_correction)
    chunk_digits, chunks = generate_chunks(data, naive_chunk_size)
    
    qrs = []
    for chunk in chunks:
        qr = qrcode.QRCode(
            version=version,
            error_correction=error_correction,
            box_size=scale,
        )
        assert len(chunk) <= naive_chunk_size
        qr.add_data(qrcode.util.QRData(chunk, mode=MODE), optimize=0)
        qr.make(fit=False)
        qrs.append(qr)

    return chunk_digits, qrs

def generate_passphrase():
    return ' '.join(random.choices(english_wordlist.words, k=8))

# I took a look at the 'gnupg' library... it doesn't support bytes, and it isn't really designed to do symmetric encryption/decryption either.
def encrypt(content_bytes, passphrase, armor=False, cipher="AES256"):
    # I chose to hardcode an encryption cipher, to make documenting the restore easier. This does make it harder to futureproof, and some people may distrust AES already.
    result = subprocess.run(["gpg", "--symmetric", "--no-symkey-cache", "--passphrase", passphrase, "--batch", "--cipher-algo"] + (["--armor"] if armor else []), capture_output=True, input=content_bytes)
    assert result.returncode == 0
    return result.stdout

def decrypt(content_bytes, passphrase):
    result = subprocess.run(["gpg", "--decrypt", "--no-symkey-cache", "--passphrase", passphrase, "--batch"], capture_output=True, input=content_bytes)
    assert result.returncode == 0
    return result.stdout

def show_help(error=None):
    if error:
        print(HELP, file=sys.stderr)
        print(file=sys.stderr)
        print("ERROR: {}".format(error), file=sys.stderr)
        sys.exit(1)
    else:
        print(HELP)
        sys.exit(0)

def add_label(image, text, side="bottom", max_fontsize=24, max_width=None, label=None):
    """
    Add a label. The fontsize is max_fontsize if possible, otherwise it's shrunk down.
    The label is aligned to the bounding box of the image (lines up with margins).
    """
    # Figure out the size and position of the original image
    bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()
    if bbox is None:
        left, upper, right, lower = 0,0,0,0
        if max_width is None:
            max_width = image.size[0]
    elif max_width is None:
        left, upper, right, lower = bbox
        max_width = right-left
    else:
        left, upper, right, lower = bbox
        right, max_width = max(right, max_width), max_width-left

    # Generate a label that fits. The fontsize will be reduced if needed. No word wrap is performed.
    if label is None:
        label = generate_label(text, max_width=max_width, max_fontsize=max_fontsize)
    else:
        assert label.size[0] <= max_width, "Premade label is too wide"
    label_bbox = PIL.ImageOps.invert(image.copy().convert("L")).getbbox()

    # Layout
    width, combined_height = max(image.size[0], left+label.size[0]), image.size[1] + label.size[1]
    labeled = PIL.Image.new(mode="1", size=(width, combined_height), color=1) #B+W
    if side == "bottom":
        labeled.paste(image, (0,0))
        labeled.paste(label, (left,image.size[1]))
    elif side == "top":
        labeled.paste(label, (left,0))
        labeled.paste(image, (0,label.size[1]))
    else:
        assert False, "Unknown side for label: {}".format(side)
    return labeled

def generate_label(text, max_width, max_fontsize=24, min_fontsize=4):
    # to do, maybe some fancy word wrap
    test_im = PIL.Image.new(mode="1", size=(1,1), color=1)
    test_draw = PIL.ImageDraw.Draw(test_im)

    for fontsize in range(max_fontsize, min_fontsize-1, -1):
        font = PIL.ImageFont.truetype("DejaVuSans.ttf", fontsize)
        width, height = test_draw.multiline_textsize(text, font=font)
        height += 4
        if width <= max_width:
            im = PIL.Image.new(mode="1", size=(width, height), color=1) # black-and-white
            draw = PIL.ImageDraw.Draw(im)
            draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
            return im
        else:
            logging.info("Reducing label size to {}".format(fontsize))
    #assert False
    logging.error("Label cannot fit in the requested width. Forcing output...")

    font = PIL.ImageFont.truetype("DejaVuSans.ttf", min_fontsize)
    width, height = test_draw.multiline_textsize(text, font=font)
    height += 4
    im = PIL.Image.new(mode="1", size=(max_width, height), color=1) # black-and-white
    draw = PIL.ImageDraw.Draw(im)
    draw.multiline_text((0,-2), text, font=font) # Eurgh, hardcoding an offset.
    return im

def h_merge(images):
    # Alignment is top-aligned
    combined_width = sum(image.size[0] for image in images)
    max_height = max(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(combined_width, max_height), color=1) #B+W
    width = 0
    for source_image in images:
        im.paste(source_image,(width, 0))
        width += source_image.size[0]
    return im

def v_merge(images):
    # Alignment is left-aligned
    max_width = max(image.size[0] for image in images)
    combined_height = sum(image.size[1] for image in images)
    im = PIL.Image.new(mode="1", size=(max_width, combined_height), color=1) #B+W
    height = 0
    for source_image in images:
        im.paste(source_image,(0, height))
        height += source_image.size[1]
    return im

def main_backup(args):
    # default settings
    qr_version = 40
    error_correction = M # default, 25%
    scale = 8
    dpi = 300
    page_w_points, page_h_points = 500,600
    restore_file = None
    use_compression = True
    output_path = None
    GENERATE_DOCS = False # Manually generate example.png for the README when qr-backup changes
    add_page_instructions = True
    add_cover_instructions = False
    notes = []
    use_encryption = False
    encryption_passphrase = None
    print_passphrase = None

    # parse arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--compress":
            use_compression = True
        elif arg == "--dpi":
            if len(args) < 1:
                show_help("--dpi requires one argument (an integer dots-per-inch)")
            dpi, args = int(args[0]), args[1:]
        elif arg == "--encrypt":
            # Note: --encrypt inherently makes the output nondeterministic. AES256 uses both a random IV and a salt.
            if len(args) < 1 or args[0].startswith("-"):
                show_help("--encrypt requires either 'generate' or a passphrase")
            use_encryption = True
            if args[0] == "generate":
                args = args[1:]
            else:
                encryption_passphrase, args = args[0], args[1:]
        elif arg == "--error-correction":
            if len(args) < 1:
                show_help("--error-correction requires one of: L M Q H")
            error_correction, args = {"L":L, "M": M, "Q": Q, "H": H}[args[0].upper()], args[1:]
        elif arg == "--filename":
            if len(args) < 1:
                show_help("--filename requires one argument")
            restore_file, args = args[0], args[1:]
            assert len(restore_file) > 0 and not restore_file.startswith("-")
        elif arg == "--generate-docs": # Development only. Don't document or use please.
            GENERATE_DOCS=True
        elif arg == "--instructions":
            if len(args) < 1:
                show_help("--instructions requires one argument")
            instruction_type, args = args[0], args[1:]
            if instruction_type == "page":
                add_page_instructions = True
                add_cover_instructions = False
            elif instruction_type == "cover":
                add_page_instructions = False
                add_cover_instructions = True
            elif instruction_type == "none":
                add_page_instructions = False
                add_cover_instructions = False
            elif instruction_type == "both":
                add_page_instructions = True
                add_cover_instructions = True
            else:
                show_help("--instructions requires one of: page cover both none")
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--note":
            if len(args) < 1:
                show_help("--note requires one argument")
            note, args = args[0], args[1:]
            for note_line in note.split("\n"):
                for line in textwrap.wrap(note_line, width=60, replace_whitespace=False):
                    notes.append(line)
        elif arg == "--page":
            if len(args) < 2:
                show_help("--page requires two arguments (decimal page width and height in inches)")
            page_w_points, page_h_points, args = float(args[0]), float(args[1]), args[2:]
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--qr-version":
            if len(args) < 1:
                show_help("--qr-version requires one argument (integer version between 2 and 40)")
            qr_version, args = int(args[0]), args[1:]
        elif arg == "--scale":
            if len(args) == 0:
                show_help("--scale requires one argument (integer scale in pixels)")
            scale, args = int(args[0]), args[1:]
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)
    if len(pargs) < 1:
        show_help("Please supply a filename to backup")
    elif len(pargs) > 1:
        show_help("Multiple filenames given. qr-backup can only back up one file at a time")
    input_path, = pargs

    use_stdout = (output_path is None) and not sys.stdout.isatty()
    use_stdin = (input_path == "-")
    if restore_file is None:
        input_filename = input_path.split("/")[-1]
        if not use_stdin and len(input_filename) <= 32:
            restore_file = input_filename
        else:
            restore_file = "file"
    if output_path is None:
        if use_stdin:
            output_path = f"{restore_file or 'stdin'}.qr.pdf"
        else:
            output_path = input_path+".qr.pdf"

    if use_encryption and print_passphrase is None:
        print_passphrase = encryption_passphrase is None

    if use_encryption and not program_present("gpg"):
        show_help("gpg must be installed to use --encrypt. could not find gpg in the PATH")

    nice_cmd = ' '.join([x for x in ["qr-backup", "--qr-version", str(qr_version), "--dpi", str(dpi), "--scale", str(scale), "--error-correction", "LMQH"[error_correction], "--page", str(page_w_points), str(page_h_points), '--compress' if use_compression else '--no-compress', "--filename", '--encrypt ???' if use_encryption else None, restore_file] if x is not None])
    if GENERATE_DOCS:
        backup_date = "2021-06-15"
    else:
        backup_date = datetime.date.today().strftime("%Y-%m-%d")
    logging.info("Original arguments were: {}".format(repr(args)))
    logging.info("Command arguments parsed. Equivalent command: {}".format(nice_cmd))

    # open the file (or stdin, if "-" is passed as the file)
    if use_stdin:
        f = sys.stdin.buffer
    else:
        f = open(input_path, "rb")

    # read the entire file into memory
    try:
        original_content = f.read()
    finally:
        f.close()

    sha256sum = hashlib.sha256(original_content).hexdigest()
    original_len = len(original_content)
    logging.info(f"read file {restore_file} (sha {sha256sum}, {original_len/1000}KB)")

    content = original_content

    # (Gzip) Compression
    if use_compression:
        content = gzip.compress(content, mtime=0)

    # Encryption
    if use_encryption:
        if encryption_passphrase is None:
            encryption_passphrase = generate_passphrase()
            print("Your secret encryption passphrase is: {}".format(encryption_passphrase), file=sys.stderr)
            print("Back this up somewhere secure or you will be unable to access your data", file=sys.stderr)
        content = encrypt(content, encryption_passphrase)

    # Generate QR codes
    code_digits, qrs = qr_codes(content, error_correction=error_correction, version=qr_version, scale=scale)

    # How to restore
    restore_cmd = f'sort -u | grep "^N" | cut -c{code_digits*2+4}- | base64 -d'
    if use_encryption:
        restore_cmd += ' | gpg --decrypt'
    if use_compression:
        restore_cmd += ' | gunzip'
    logging.info(f"Restore command is: {restore_cmd}")

    # Instructions depend on the command line options, and the content of the file
    HOWTO = f'This is a paper backup of a computer file called: {restore_file}'
    HOWTO += '\nTo restore this file using qr-backup:'
    HOWTO += f'\n  Step 1 (webcam): qr-backup --restore'
    HOWTO += f'\n  Step 1 (scanner): qr-backup --restore IMAGE1 IMAGE2 ...'
    HOWTO += '\nTo restore this file from the command line in Linux:'
    HOWTO += f'\n  Step 1 (webcam option): zbarcam --raw | tee /tmp/qrs | cut -c1-{code_digits+1} # Scan each code at least once in any order'
    HOWTO += f'\n  Step 1 (scanner option): zbarimg -q --raw *.png >/tmp/qrs'
    howto_restore_cmd = restore_cmd.replace("sort -u", "sort -u /tmp/qrs")
    HOWTO += f'\n  Step 2 (restore): {howto_restore_cmd} >{restore_file}'
    HOWTO += f'\n  Step 3 (verify): sha256sum {restore_file} # {sha256sum}, {original_len} bytes'
    HOWTO += f'\nThis backup was generated on {backup_date} with: {nice_cmd}'
    if len(notes) > 0:
        HOWTO += "\n" + "\n".join(["Additional note: " + note for note in notes])

    cover_txt = COVER.format(
        backup_date=backup_date,
        restore_file=restore_file,
        original_len=original_len,
        sha256sum=sha256sum,
        nice_cmd=nice_cmd,
        notes="\n".join(["Additional note: " + note for note in notes])+"\n" if len(notes) > 0 else "",
        code_end=code_digits+1,
        howto_restore_cmd=howto_restore_cmd,
    )

    # Calculate QR padding produced by qrcode module
    example_qr = qrs[0].make_image().copy()
    qr_bbox = PIL.ImageOps.invert(example_qr.copy().convert("L")).getbbox()
    qr_lpad, qr_tpad, qr_rpad, qr_bpad = qr_bbox[0], qr_bbox[1], example_qr.size[0]-qr_bbox[2], example_qr.size[1]-qr_bbox[3]
    qr_hpad, qr_vpad = qr_lpad + qr_rpad, qr_tpad + qr_bpad

    # Output QR codes with labels to Pillow Image objects
    labeled = []
    for i, qr in enumerate(qrs):
        img = qr.make_image()
        label = f"code {i+1:0>{code_digits}}/{len(qrs):0>{code_digits}} {restore_file}"
        labeled.append(add_label(img, label))
    logging.info(f"{len(qrs)} qr codes (at version {qr_version}) total")

    # Figure out page layout now that we know the size and number of QR codes. Output to the user.
    qr_w_pixel, qr_h_pixel = labeled[0].size
    logging.info(f"QR code (including label) is: {qr_w_pixel}x{qr_w_pixel}px")

    page_w_pixel, page_h_pixel = math.floor(page_w_points/72.0*dpi), math.floor(page_h_points/72.0*dpi) # 1 "dot" = 1 pixel. !!important note, DPI is not used yet, which is probably some config bug in Pillow
    logging.info(f"Page is: {page_w_pixel}x{page_h_pixel}px")

    if add_page_instructions:
        howto_label = generate_label(HOWTO, page_w_pixel - qr_hpad)
        howto_height = howto_label.size[1]
    else:
        howto_height = 0
    
    page_w_qr, page_h_qr = math.floor((page_w_pixel-2) // qr_w_pixel), math.floor((page_h_pixel-2-howto_height) // qr_h_pixel)
    qr_per_page = page_w_qr * page_h_qr
    if qr_per_page == 0:
        logging.error("Not even 1 QR fits on the given page. Forcing output anyway...")
        page_w_qr, page_h_qr, qr_per_page = 1,1,1
    num_qr_pages = math.ceil(len(qrs)/qr_per_page)
    logging.info(f"{page_w_qr} x {page_h_qr} qr codes (at version {qr_version}) per page. {num_qr_pages} pages total")

    density = original_len / num_qr_pages
    logging.info(f"{len(content)} bytes in {num_qr_pages} ({density/1000:.2f}KB/page)")

    # Combine rows
    rows = []
    for row_start in range(0, len(qrs), page_w_qr):
        row_qrs = labeled[row_start:row_start+page_w_qr]
        rows.append(h_merge(row_qrs))

    # Use imagemagick to make one png file per page-side
    unnumbered_images = []
    if print_passphrase:
        passphrase_image = generate_label("File: {}\nDate: {}\nYour secret passphrase is: {}\n\nMake sure to hide this sheet somewhere secure, not with your backup!".format(restore_file, backup_date, encryption_passphrase), max_width=page_w_pixel-2)
        unnumbered_images.append((False, passphrase_image))
    if add_cover_instructions:
        cover_img = generate_label(cover_txt, page_w_pixel - qr_hpad, max_fontsize=24, min_fontsize=24)
        assert cover_img.size[0] <= page_w_pixel - 2
        unnumbered_images.append((True, cover_img))
    for page_start in range(0, len(rows), page_h_qr):
        page_rows = rows[page_start:page_start+page_h_qr]
        page_qrs = v_merge(page_rows)
        if add_page_instructions:
            page_complete = add_label(page_qrs, HOWTO, side="top", max_fontsize=24, max_width=page_w_pixel-2)
            unnumbered_images.append((True, page_complete))
        else:
            unnumbered_images.append((True, page_qrs))

    # Add a rectangle border and pad any small ones to full-page size
    unnumbered_pages = []
    for should_number, img in unnumbered_images:
        #assert img.size[0] <= page_w_pixel-2 and img.size[1] <= page_h_pixel-2
        if GENERATE_DOCS:
            page_h_pixel = img.size[1]+2 # minimize size for example.png
        page = PIL.Image.new(mode="1", size=(page_w_pixel, page_h_pixel), color=1)
        page_draw = PIL.ImageDraw.Draw(page)
        page_draw.rectangle(((0,0), (page_w_pixel-1, page_h_pixel-1)), outline=0, fill=1, width=1) # Rectangle for debugging print cutoff, and to look nice.
        page.paste(img, (1,1)) # Main contents
        unnumbered_pages.append((should_number, page))

    # Add page numbers after. Currently page-numbering is perfectly reliable, but we're about to add more complicated layout options.
    pages = []
    num_pages = len(unnumbered_pages)
    for page_num, (should_number, page) in enumerate(unnumbered_pages):
        if should_number:
            page_num = generate_label("page {}/{}".format(page_num+1, num_pages), max_width=example_qr.size[0]/2)
            page.paste(page_num, (page.size[0]-page_num.size[0]-1-qr_rpad, page.size[1]-page_num.size[1]-11)) # Page num in bottom-right
        pages.append(page)

    # PIL's pdf writer needs to mmap, so it can't accept sys.stdout directly
    tmp_pdf = io.BytesIO()
    pages[0].save(tmp_pdf, format="pdf", save_all=True, append_images=pages[1:], resolution=dpi, producer="qr-backup", title=f"qr-backup paper backup of {restore_file} with sha256 {sha256sum} and length {original_len}", creationDate=backup_date, modDate=backup_date)

    if use_stdout: 
        # Write PDF to stdout
        sys.stdout.buffer.write(tmp_pdf.getbuffer())
    else:
        # Write PDF to file
        with open(output_path, "wb") as f:
            f.write(tmp_pdf.getbuffer())

    # Self-test
    if use_encryption:
        test_restore_cmd = restore_cmd.replace("gpg --decrypt", "gpg --decrypt --no-symkey-cache --batch --passphrase '{}'".format(encryption_passphrase))
        logging.info("Restore command used in Linux CLI test: " + test_restore_cmd)
    else:
        test_restore_cmd = restore_cmd
    
    if program_present("zbarimg"):
        if use_stdout or use_stdin:
            logging.info("Performing linux CLI restore check...")
            # convert -density 300 is to work around errors in zbarcam
            linux_test_command = "zbarimg --raw -q -Sdisable -Sqrcode.enable - | {}".format(test_restore_cmd)
            linux_test = subprocess.run(linux_test_command, shell=True, capture_output=True, input=tmp_pdf.getbuffer())
            linux_success = linux_test.returncode==0 and linux_test.stdout == original_content

            logging.info("Performing qr-backup restore check...")
            self_test_command = ["python3", sys.argv[0], "--restore", "--sha256", sha256sum, "-"]
            if use_encryption:
                self_test_command += ["--encrypt", encryption_passphrase]
            self_test = subprocess.run(self_test_command, capture_output=True, input=tmp_pdf.getbuffer())
            self_test_success = self_test.returncode==0
        else:
            logging.info("Performing linux CLI restore check...")
            linux_test_command = "zbarimg --raw -q -Sdisable -Sqrcode.enable {} | {} | cmp {}".format(output_path, test_restore_cmd, input_path)
            linux_success = (subprocess.call(linux_test_command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)
            logging.info("Performing qr-backup restore check...")
            self_test_command = ["python3", sys.argv[0], "--restore", "--sha256", sha256sum, output_path]
            if use_encryption:
                self_test_command += ["--encrypt", encryption_passphrase]
            self_test_success = (subprocess.call(self_test_command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) == 0)

        if not linux_success:
            logging.error("!!Automatic digital restore verification FAILED (linux CLI). This indicates a bug in either zbarimg (more likely) or in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
            #sys.exit(1)
        elif not self_test_success:
            logging.error("!!Automatic digital restore verification FAILED (self-test). This indicates a bug in qr-backup. Please report this to the author at https://github.com/za3k/qr-backup/issues")
            #sys.exit(1)
        else:
            logging.info("Automatic digital restore verification succeeded.")
    else:
        logging.warning("Skipping digital restore verification, because zbarimg is not available.")

    if GENERATE_DOCS:
        pages[0].save("docs/example.png")
        with open("docs/USAGE.md", "w") as f:
            f.write("Output of `qr-backup --help`:\n")
            f.write("\n")
            f.write("```\n")
            f.write(HELP)
            f.write("\n")
            f.write("```\n")

def image_restore(image_paths):
    # Special note: image_paths can include "-", in which case zbarimg will magically do the right thing
    if not program_present("zbarimg"):
        logging.fatal("zbarimg not found. install 'zbar' to scan files.")
        sys.exit(2)

    scan_command = ["zbarimg", "--raw", "-q", "-Sdisable", "-Sqrcode.enable"] + image_paths
    result = subprocess.run(scan_command, capture_output=True)
    for line in result.stdout.split(b"\n"):
        if line != b'':
            yield line

def webcam_restore(use_display):
    if not program_present("zbarcam"):
        logging.fatal("zbarcam not found. install 'zbar' to scan using your camera.")
        sys.exit(2)

    scan_command = ["zbarcam", "--raw", "-Sdisable", "-Sqrcode.enable"]
    if not use_display:
        scan_command.append("--nodisplay")

    with subprocess.Popen(scan_command, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL) as proc:
        while True:
            line = proc.stdout.readline()
            if line == b'':
                return
            if (yield line):
                return

def expected_codes(codes, code_count): # Returns a list of binary strings
    code_digits = math.ceil(math.log(code_count+1,10))
    return [f"N{i:>0{code_digits}}".encode('ascii') for i in range(1, code_count+1)]
def restore_status(codes, code_count):
    if code_count is None:
        return f"{len(codes)}/??? codes read"
    else:
        missing = [x.decode('ascii') for x in expected_codes(codes, code_count) if x not in codes]
        return f"Missing {len(missing)}/{code_count} codes: " + ' '.join(x[1:] for x in missing[:5]) + (" ..." if len(missing) > 5 else "")
def is_complete(codes, code_count):
    if code_count is None:
        return False
    return all(x in codes for x in expected_codes(codes, code_count))
def do_restore(codes, code_count, use_compression, use_encryption, encryption_passphrase):
    assert is_complete(codes, code_count)

    # Base-64 decode (per qr-code)
    decoded = {k: base64.b64decode(v) for k,v in codes.items()}

    # Concat
    content = b''.join(decoded[x] for x in expected_codes(codes, code_count))

    # Decrypt
    if use_encryption is None:
        use_encryption = content.startswith(b"-----BEGIN PGP MESSAGE-----")
    if use_encryption is True:
        content = decrypt(content, encryption_passphrase)

    # Decompress
    if use_compression is True:
        content = gzip.decompress(content)
    elif use_compression is None: # automatic determination
        try:
            content = gzip.decompress(content)
            use_compression = True
        except gzip.BadGzipFile:
            use_compression = False

    return content

def main_restore(args):
    # Default config
    restore_method = None # Should be one of: None, "webcam", "images"

    output_path = None # Should be one of: None (for use_stdout), file path
    use_stdout = False
    code_count = None # Should be one of: None (infer) or a number
    use_display = True

    expected_sha256sum = None
    use_compression = None
    use_encryption = None
    encryption_passphrase = None

    # Parse command-line arguments
    pargs = []
    while len(args) > 0:
        arg, args = args[0], args[1:]
        if arg in ["-h", "--help"]:
            show_help()
        elif arg == "--code-count":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            code_count, args = int(args[0]), args[1:]
        elif arg == "--compress":
            use_compression = True
        elif arg == "--display":
            use_display = True
        elif arg == "--encrypt":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            use_encryption = True
            encryption_passphrase, args = args[0], args[1:]
        elif arg == "--image-restore":
            restore_method = "images"
        elif arg == "--no-compress":
            use_compression = False
        elif arg == "--no-encrypt":
            use_encryption = False
        elif arg == "--no-display":
            use_display = False
        elif arg in ["-o", "--output"]:
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            output_path, args = args[0], args[1:]
        elif arg == "--sha256":
            if len(args) < 1:
                show_help("{} requires one argument".format(arg))
            expected_sha256sum, args = args[0].lower(), args[1:]
            if not all(x in "0123456789abcdef" for x in expected_sha256sum):
                show_help("Not a valid SHA256: {}".format(expected_sha256sum))
        elif arg in ["-v", "--verbose"]:
            logging.basicConfig(level=logging.INFO)
        elif arg == "--webcam-restore":
            restore_method = "webcam"
        elif arg == "-":
            pargs.append(arg)
        elif arg == "--":
            # Stop parsing arguments
            pargs, args = pargs + args, []
        elif arg.startswith("-"):
            show_help()
        else:
            pargs.append(arg)

    assert len([x for x in pargs if x == "-"]) <= 1, "stdin can be listed as an image only once"
    if restore_method is None and len(pargs) == 0 and not sys.stdin.isatty():
        logging.debug("Reading from stdin")
        restore_method = "images"
        pargs = ["-"]
    elif restore_method is None and len(pargs) == 0:
        restore_method = "webcam"
    elif restore_method is None and len(pargs) > 0:
        restore_method = "images"

    if output_path is None:
        use_stdout = True

    if use_encryption and not program_present("gpg"):
        show_help("gpg must be installed to use --encrypt. could not find gpg in the PATH")

    # Call a subprocess to do the restore
    if restore_method == "images":
        logging.info("image restore selected")
        restore_generator = image_restore(pargs)
    elif restore_method == "webcam":
        logging.info("webcam restore selected")
        restore_generator = webcam_restore(use_display=use_display)
    else:
        assert False

    # Scan codes one at a time until done
    codes = {}
    while not is_complete(codes, code_count):
        # Print status line
        if restore_method == "webcam":
            if code_count is None:
                print("Hold up QR codes to the webcam in any order.",file=sys.stderr)
            else:
                print(restore_status(codes, code_count),file=sys.stderr)

        # Read the next code as binary data
        try:
            read_code = next(restore_generator)
        except StopIteration:
            logging.fatal("Not enough codes could be read to restore the file. Exiting.")
            sys.exit(3)

        # Parse the label out
        assert b"\n" not in read_code
        code_label, content = read_code.split(b' ', maxsplit=1)
        code_num, total = code_label.split(b'/')
        total = int(total.decode('ascii'))
        if code_count is None:
            code_count = total
        elif code_count == total:
            pass
        elif code_count != total and len(codes) == 0:
            logging.fatal("Code count disagrees with --code-count option (Code={}, --code-count={})".format(code_label.decode('ascii'), code_count))
            sys.exit(4)
        elif code_count != total and len(codes) != 0:
            logging.fatal("Code count disagrees for codes: {} & {}".format(code, next(iter(code.keys()))))
            sys.exit(4)
        else:
            assert False
        assert code_count is not None

        # Add the code
        if code_num in codes and codes[code_num] == content:
            logging.info(f"Read duplicate code {code_num}: IDENTICAL")
        elif code_num in codes and codes[code_num] != content:
            logging.error(f"Read duplicate code {code_num}: DIVERGES")
        elif code_num not in codes:
            logging.info(f"Read new code {code_num}")
        else:
            assert False
        codes[code_num] = content
    # Close subprocess
    # TODO: Sometimes one extra code needs to be read before it closes, fix that.
    next(restore_generator, True)

    # Do the restore
    content = do_restore(codes, code_count, use_compression=use_compression, use_encryption=use_encryption, encryption_passphrase=encryption_passphrase)

    # Check the checksum
    sha256sum = hashlib.sha256(content).hexdigest()
    exit_status = 0
    logging.info("restored sha256sum: {}".format(sha256sum))
    if expected_sha256sum is None:
        logging.debug("no expected sha256sum was given")
        print(f"sha256sum was as follows, please check against your paper backup: {sha256sum}", file=sys.stderr)
    elif expected_sha256sum == sha256sum:
        logging.debug("sha256sum matched")
        #print("File verified using sha256 checksum.", file=sys.stderr)
    elif sha256sum.startswith(expected_sha256sum):
        logging.debug("sha256sum partial matched")
        print(f"The actual sha256sum begins with checksum given on the command line, but it was not complete. The full checksum was: {sha256sum}", file=sys.stderr)
    else:
        logging.error("sha256sum did not match")
        exit_status = 4
        print(f"!!The restored file does NOT match the expected checksum. Restoring anyway.", file=sys.stderr)

    # Write the output
    if use_stdout:
        sys.stdout.buffer.write(content)
    else:
        with open(output_path, "wb") as f:
            f.write(content)
    sys.exit(exit_status)

if __name__ == "__main__":
    # parse command-line arguments
    args = sys.argv[1:]
    if len(args) > 1 and args[0] in ["-r", "--restore"]:
        main_restore(args[1:])
    else:
        main_backup(args)
